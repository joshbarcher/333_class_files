package tests;

import adts.ISet;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import structures.SetLL;

import java.util.*;

/**
 * Tests an implementation of the ISet interface.
 *
 * DO NOT EDIT THIS FILE!
 *
 * @author Josh Archer
 * @version 1.0
 */
public class SetTest
{
    private ISet<Integer> set;

    //test arrays
    private Integer[] noDupsArray = {5, 8, 7, 4, 3, 6};
    private Integer[] dupsArray = {3, 5, 5, 6, 3, 6};
    private int[] missing = {1, 2, 9, 10};

    /*
        This method should create and return a new set
        for the methods below.
     */
    private ISet<Integer> createSet()
    {
        //instantiate your class here!
        return null;
    }

    /**
     * Creates a new set before each test.
     */
    @Before
    public void setup()
    {
        set = createSet();
    }

    /**
     * Tests whether elements can be added to
     * the set successfully.
     */
    @Test
    public void addingElementsTest()
    {
        addNoDupsElements();

        for (int i = 0; i < noDupsArray.length; i++)
        {
            Assert.assertTrue("Elements added to set not discoverable with contains()",
                                set.contains(noDupsArray[i]));
        }
    }

    /**
     * Tests whether duplicate elements are rejected after
     * calling add().
     */
    @Test
    public void duplicateElementsTest()
    {
        int dupsCount = 0;
        for (int i = 0; i < dupsArray.length; i++)
        {
            try
            {
                set.add(dupsArray[i]);
            }
            catch (IllegalStateException ex)
            {
                dupsCount++;
            }
        }

        //three dups should be found
        Assert.assertEquals("All three duplicate elements were not rejected",
                            3, dupsCount);

        //there are three unique elements in the input array
        Assert.assertEquals("There should be three unique elements in the set " +
                            "after rejected duplicates", 3, set.size());
    }

    /**
     * Verifies that the element count in the set is correct
     * after calling addAll().
     */
    @Test
    public void addAllTest()
    {
        set.addAll(noDupsArray);
        Assert.assertEquals("There should be " + noDupsArray.length +
                            " unique elements in the set after calling addAll()",
                            noDupsArray.length, set.size());
    }

    /**
     * Verifies that duplicates are caught between
     * input parameters and elements already in the set.
     */
    @Test(expected = IllegalStateException.class)
    public void addAllDuplicateElementsTest()
    {
        addNoDupsElements();
        set.addAll(noDupsArray);
    }

    /**
     * Verifies that duplicate parameters result in
     * an exception.
     */
    @Test(expected = IllegalStateException.class)
    public void addAllDuplicateParametersTest()
    {
        set.addAll(dupsArray);
    }

    /**
     * Verifies that the set reports the size of the structure
     * correctly.
     */
    @Test
    public void sizeTest()
    {
        addNoDupsElements();

        //list should be empty to start with
        Assert.assertEquals("List should have size " + noDupsArray.length +
                            "after calls to add()", noDupsArray.length,
                            set.size());
        Assert.assertFalse("List should not be empty after calling add()", set.isEmpty());
    }

    /**
     * Verifies that the set reports the size of the structure
     * correctly.
     */
    @Test
    public void sizeEmptyTest()
    {
        //list should be empty to start with
        Assert.assertEquals("List should have size 0 after no calls to add()",
                            0, set.size());
        Assert.assertTrue("List should be empty after no calls to add()", set.isEmpty());
    }

    /**
     * Verifies that elements can be found in the set
     * with contains().
     */
    @Test
    public void containsExistsTest()
    {
        addNoDupsElements();

        //make sure elements are discoverable
        for (int i = 0; i < noDupsArray.length; i++)
        {
            Assert.assertTrue("Added element not discoverable by contains()",
                                set.contains(noDupsArray[i]));
        }
    }

    /**
     * Verifies that elements not in the set cannot be discovered
     * with contains().
     */
    @Test
    public void containsMissingTest()
    {
        addNoDupsElements();

        //make sure elements are discoverable
        for (int i = 0; i < missing.length; i++)
        {
            Assert.assertFalse("Missing element is discoverable by contains()",
                                set.contains(missing[i]));
        }
    }

    /**
     * Verifies that contains() does not return true
     * when the set is empty.
     */
    @Test
    public void containsOnEmptyListTest()
    {
        //contains should always return false on empty set
        Assert.assertFalse("Missing element is discoverable by contains()",
                            set.contains(3));

        //add an element and confirm contains() can discover it
        set.add(3);
        Assert.assertTrue("Element added to set is not discoverable by contains()",
                            set.contains(3));
    }

    /**
     * Removes several elements from the set and verifies that
     * they are no longer in the set.
     */
    @Test
    public void removeExistsTest()
    {
        addNoDupsElements();

        //get a random remove order
        Integer[] shuffled = shuffleNewArray(noDupsArray);

        //remove in random order
        for (int i = 0; i < shuffled.length; i++)
        {
            set.remove(shuffled[i]);
        }

        Assert.assertEquals("List size should be 0 after removing all elements", 0, set.size());
        Assert.assertTrue("List should be empty after removing all elements", set.isEmpty());
    }

    private Integer[] shuffleNewArray(Integer[] array)
    {
        Random random = new Random();
        Integer[] copied = new Integer[array.length];
        System.arraycopy(array, 0, copied, 0, array.length);

        for (int i = 0; i < copied.length; i++)
        {
            swap(i, random.nextInt(copied.length), copied);
        }

        return copied;
    }

    private void swap(int first, int second, Integer[] array)
    {
        int temp = array[first];
        array[first] = array[second];
        array[second] = temp;
    }

    /**
     * Verifies that missing elements cannot be removed
     * from the set.
     */
    @Test
    public void removeMissingTest()
    {
        addNoDupsElements();

        //each of these removals should throw an exception
        for (int i = 0; i < missing.length; i++)
        {
            try
            {
                set.remove(missing[i]);

                //fail, an exception should have occurred...
                Assert.fail("No exception is thrown when removing a missing element");
            }
            catch (NoSuchElementException ex)
            {
                //do nothing, this is correct...
                assert true;
            }
        }
    }

    /**
     * Verifies that the correct exception is thrown when
     * removing from an empty set.
     */
    @Test(expected = NoSuchElementException.class)
    public void removeOnEmptySetTest()
    {
        //no elements are present, this should give an exception
        set.remove(2);
    }

    /**
     * Verifies that clear() works correctly on an empty
     * set.
     */
    @Test
    public void clearEmptyTest()
    {
        //make sure no errors are encountered
        set.clear();

        Assert.assertEquals("Set size should be 0 after calling clear()", 0, set.size());
        Assert.assertTrue("Set should be empty after calling clear", set.isEmpty());
    }

    /**
     * Verifies that clear() works correctly on a non-empty
     * set.
     */
    @Test
    public void clearNotEmptyTest()
    {
        addNoDupsElements();

        //make sure no errors are encountered
        set.clear();

        Assert.assertEquals("Set size should be 0 after calling clear()", 0, set.size());
        Assert.assertTrue("Set should be empty after calling clear", set.isEmpty());
    }

    /**
     * Tests a large number of elements within the set.
     */
    @Test
    public void largeSetTest()
    {
        //add enough elements for force a resize
        for (int i = 1; i <= 1000; i++)
        {
            set.add(i);
        }

        //make sure elements are discoverable
        for (int i = 1; i <= 1000; i++)
        {
            Assert.assertTrue("Element is not discoverable by contains()",
                                set.contains(i));
        }

        //number of elements should not be zero
        Assert.assertEquals("Set size should be 1000 after calling add 1000 times",
                               1000, set.size());
        Assert.assertFalse("Set should not be empty after calling add()", set.isEmpty());
    }

    /**
     * Verifies that add() works correctly after adding
     * elements, removing all elements, then inserting
     * a new element.
     */
    @Test
    public void addAfterEmptyingSetTest()
    {
        addNoDupsElements();

        //remove all elements
        for (int i = 0; i < noDupsArray.length; i++)
        {
            set.remove(noDupsArray[i]);
        }

        //adding should still be successful
        set.add(2);
        Assert.assertEquals("The size of your set should be 1 after calling add() on an empty set",
                            1, set.size());
    }

    /**
     * Verifies that an iterator can be retrieved and used
     * on an empty set.
     */
    @Test
    public void iteratorWithEmptySetTest()
    {
        Iterator<Integer> iter = set.iterator();
        Assert.assertFalse("Iterator should not report elements for an empty set",
                iter.hasNext());
    }

    /**
     * Verifies that the iterator is returning elements.
     */
    @Test
    public void iteratorTest()
    {
        addNoDupsElements();

        //verify elements returned in order
        Iterator<Integer> iter = set.iterator();
        for (int i = 0; i < noDupsArray.length; i++)
        {
            Assert.assertTrue("hasNext() should return true for existing elements in the list",
                    iter.hasNext());
            Assert.assertTrue("next() should return all elements",
                    foundInNoDuplicatesArray(iter.next()));
        }

        Assert.assertFalse("Iterator should not report more elements after all have been returned",
                iter.hasNext());
    }

    /**
     * Verifies that a for-each loop works correctly with the set.
     */
    @Test
    public void forEachTest()
    {
        addNoDupsElements();

        //a for-each loop should run without error
        int count = 0;
        for (int element : set)
        {
            Assert.assertTrue("next() should return all elements",
                    foundInNoDuplicatesArray(element));
            count++;
        }
    }

    private boolean foundInNoDuplicatesArray(int search)
    {
        for (int i = 0; i < noDupsArray.length; i++)
        {
            if (noDupsArray[i] == search)
            {
                return true;
            }
        }
        return false;
    }

    /**
     * Verifies that elements cannot be removed while
     * using an iterator.
     */
    @Test(expected = ConcurrentModificationException.class)
    public void concurrentRemoveTest()
    {
        addNoDupsElements();

        for (int element : set)
        {
            assert element != 0;
            set.remove(element); //alter elements while iterating
        }
    }

    /**
     * Verifies that elements cannot all be removed while
     * using an iterator.
     */
    @Test(expected = ConcurrentModificationException.class)
    public void concurrentClearTest()
    {
        addNoDupsElements();

        for (int element : set)
        {
            assert element != 0;
            set.clear(); //alter elements while iterating
        }
    }

    /**
     * Verifies that elements cannot be added while
     * using an iterator.
     */
    @Test(expected = ConcurrentModificationException.class)
    public void concurrentAddTest()
    {
        addNoDupsElements();

        for (int element : set)
        {
            set.add(element + 10); //alter elements while iterating
        }
    }

    private void addNoDupsElements()
    {
        for (int i = 0; i < noDupsArray.length; i++)
        {
            set.add(noDupsArray[i]);
        }
        Assert.assertEquals("The size of your set should be " + noDupsArray.length +
                            "after calling add()", noDupsArray.length, set.size());
    }
}
