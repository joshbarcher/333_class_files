package tests;

import adts.IBoundedQueue;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Tests an implementation of the IBoundedQueue interface.
 *
 * DO NOT EDIT THIS FILE!
 *
 * @author Josh Archer
 * @version 1.0
 */
public class QueueTest
{
    private IBoundedQueue<Integer> queue;

    //test elements
    private int[] testArray = {1, 2, 3, 4, 5};
    private int[] missing = {6, 7, 8};

    /*
        This method should create and return a new queue
        for the methods below.
     */
    private IBoundedQueue<Integer> createQueue(int capacity)
    {
        return null;
    }

    /**
     * Creates a new queue before each of the tests below.
     */
    @Before
    public void setup()
    {
        queue = createQueue(5);
    }

    /**
     * Verifies that a zero-length queue cannot be created.
     */
    @Test(expected = IllegalStateException.class)
    public void zeroCapacityTest()
    {
        queue = createQueue(0);
    }

    /**
     * Verifies that a negative-length queue cannot be created.
     */
    @Test(expected = IllegalStateException.class)
    public void negativeCapacityTest()
    {
        queue = createQueue(-4);
    }

    /**
     * Verifies that the capacity is being accurately reported
     * based on the constructor.
     */
    @Test
    public void capacityAccurateTest()
    {
        queue = createQueue(3);
        Assert.assertEquals("Capacity inaccurate when creating a queue with capacity 3",
                            3, queue.getCapacity());

        queue = createQueue(5);
        Assert.assertEquals("Capacity inaccurate when creating a queue with capacity 5",
                            5, queue.getCapacity());
    }

    /**
     * Verifies that
     */
    @Test(expected = IllegalStateException.class)
    public void fullQueueTest()
    {
        addElementsToFullQueue();

        //one too many for a queue of size 5
        queue.add(6);
    }

    /**
     * Verifies that you cannot remove an element from
     * an empty queue.
     */
    @Test(expected = NoSuchElementException.class)
    public void emptyQueueTest()
    {
        //remove a missing element
        queue.remove();
    }

    /**
     * Verifies that an element can be removed from the queue.
     */
    @Test
    public void removeTest()
    {
        addElementsToFullQueue();

        //remove the element
        int removed = queue.remove();
        Assert.assertEquals("Added a single element, but didn't receive the " +
                            "element with remove()", 1, removed);
    }

    /**
     * Verifies that elements are returned in FIFO order.
     */
    @Test
    public void fifoTest()
    {
        addElementsToFullQueue();

        //make sure elements removed are in FIFO order
        for (int i = 0; i < testArray.length; i++)
        {
            Assert.assertEquals("Removed element does not match FIFO order",
                                testArray[i], queue.remove().intValue());
        }
    }

    /**
     * Verifies that elements that are in the queue
     * can be found
     */
    @Test
    public void containsExistsTest()
    {
        addElementsToFullQueue();

        //make sure elements are discoverable
        for (int i = 0; i < testArray.length; i++)
        {
            Assert.assertTrue("Added element not discoverable by contains()",
                                queue.contains(testArray[i]));
        }
    }

    /**
     * Verifies that missing elements are not found with
     * contains().
     */
    @Test
    public void containsMissingTest()
    {
        addElementsToFullQueue();

        //make sure elements are discoverable
        for (int i = 0; i < missing.length; i++)
        {
            Assert.assertFalse("Missing element is discoverable by contains()",
                                queue.contains(missing[i]));
        }
    }

    /**
     * Verifies that missing elements cannot be found
     * with contains() on an empty queue.
     */
    @Test
    public void containsOnEmptyQueueTest()
    {
        //contains should always return false on empty queue
        Assert.assertFalse("Missing element is discoverable by contains()",
                            queue.contains(9));

        //add an element and confirm contains() can discover it
        queue.add(9);
        Assert.assertTrue("Element added to queue is not discoverable by contains()",
                            queue.contains(9));
    }

    /**
     * Verifies that a missing element results in an exception.
     */
    @Test(expected = UnsupportedOperationException.class)
    public void removeElementTest()
    {
        //this should always result in an exception
        queue.remove(2);
    }

    /**
     * Verifies that the size of the queue is reported correctly
     * for an empty queue.
     */
    @Test
    public void initialStateTest()
    {
        //queue should be empty to start with
        Assert.assertEquals("Queue should have size 0 when created", 0, queue.size());
        Assert.assertTrue("Queue should be empty when created", queue.isEmpty());
    }

    /**
     * Verifies that a queue with elements can report
     * how many are present correctly.
     */
    @Test
    public void sizeTest()
    {
        addElementsToPartialQueue();

        //queue should be empty to start with
        Assert.assertEquals("Queue size not correct after a few calls to add()",
                            testArray.length / 2, queue.size());
        Assert.assertFalse("Queue should not be empty after calling add()", queue.isEmpty());
    }

    /**
     * Verifies that adding more elements above the capacity results
     * in an exception and afterwards the
     */
    @Test
    public void sizeShouldNotExceedCapacityTest()
    {
        //add a few elements
        try
        {
            addElementsToFullQueue();
            queue.add(6);
        }
        catch (IllegalStateException ex)
        {
            //swallow the exception (if it occurs) and check the results
            assert true;
        }

        //queue should be empty to start with
        Assert.assertEquals("The size of your queue is exceeding the capacity",
                            testArray.length, queue.size());
        Assert.assertFalse("Queue should not be empty after calling add()", queue.isEmpty());
    }

    /**
     * Verifies that isFull() reports correctly for an empty queue.
     */
    @Test
    public void notFullTest()
    {
        Assert.assertTrue("Empty queue should be empty", queue.isEmpty());
        Assert.assertFalse("An empty queue should not be full", queue.isFull());
    }

    /**
     * Verifies that isFull() reports correctly for a partially full queue.
     */
    @Test
    public void semiFullTest()
    {
        addElementsToPartialQueue();

        Assert.assertEquals("Queue size not correct after a few calls to add()",
                            testArray.length / 2, queue.size());
        Assert.assertFalse("A partially filled queue should not be full", queue.isFull());
    }

    /**
     * Verifies that isFull() reports correctly for a full queue.
     */
    @Test
    public void fullTest()
    {
        addElementsToFullQueue();

        Assert.assertTrue("Queue should be full once size is the same as capacity", queue.isFull());
    }

    /**
     * Verifies that the size is reported correctly after calling
     * clear on an empty queue.
     */
    @Test
    public void clearEmptyTest()
    {
        //make sure no errors are encountered
        queue.clear();

        Assert.assertEquals("Queue size should be 0 after calling clear()", 0, queue.size());
        Assert.assertTrue("Queue should be empty after calling clear", queue.isEmpty());
        Assert.assertFalse("Queue should be empty after calling clear", queue.isFull());
    }

    /**
     * Verifies that the size is reported correctly after calling
     * clear on a non-empty queue.
     */
    @Test
    public void clearNotEmptyTest()
    {
        addElementsToPartialQueue();

        //make sure no errors are encountered
        queue.clear();

        Assert.assertEquals("Queue size should be 0 after calling clear()", 0, queue.size());
        Assert.assertTrue("Queue should be empty after calling clear", queue.isEmpty());
    }

    /**
     * Verifies that the queue behaves as expected when given
     * a large number of elements.
     */
    @Test
    public void largeQueueTest()
    {
        //create a large queue
        queue = createQueue(1000);

        //add a few elements
        for (int i = 1; i <= 1000; i++)
        {
            queue.add(i);
        }

        Assert.assertEquals("Queue should have a size of 1000 after 1000 additions", 1000, queue.size());
        Assert.assertFalse("Queue should not be empty after 1000 additions", queue.isEmpty());
        Assert.assertTrue("Queue should be full once size is the same as capacity", queue.isFull());

        //elements should be returned in order
        for (int i = 1; i <= 1000; i++)
        {
            Assert.assertEquals("Elements not returned in FIFO order", queue.remove().intValue(), i);
        }
    }

    /**
     * Verifies that intermixed calls to add() and remove()
     * behave correctly.
     */
    @Test
    public void regularModificationsTest()
    {
        //repeatedly add/remove elements
        for (int i = 1; i <= 4; i++)
        {
            //add 2
            int[] elemsToAdd = {2, 4};
            for (int j = 0; j < elemsToAdd.length; j++)
            {
                queue.add(elemsToAdd[j]);
            }

            //remove 1
            for (int j = 0; j < elemsToAdd.length - 1; j++)
            {
                queue.remove();
            }
        }

        //There should be four net elements in the end
        Assert.assertEquals("The number of elements left in the queue after repeatedly " +
                            "calling add() and remove() is incorrect", 4, queue.size());
        Assert.assertFalse("The queue should not be empty after repeatedly calling add() and remove()",
                            queue.isEmpty());
    }

    /**
     * Verifies that add works correctly after removing all
     * elements from the queue.
     */
    @Test
    public void addAfterEmptyingQueueTest()
    {
        addElementsToFullQueue();

        for (int i = 0; i < testArray.length; i++)
        {
            queue.remove();
        }

        //add a single element after emptying the queue
        queue.add(8);
        Assert.assertEquals("Queue should have a size of 1 after adding a single " +
                            "element to a 'recently' emptied queue", 1, queue.size());
        Assert.assertTrue("Queue should detect a single element after emptying the queue",
                            queue.contains(8));
    }

    /**
     * Verifies that an iterator is returned for an empty
     * queue.
     */
    @Test
    public void iteratorWithEmptyQueueTest()
    {
        Iterator<Integer> iter = queue.iterator();
        Assert.assertFalse("Iterator should not report elements for an empty queue",
                iter.hasNext());
    }

    /**
     * Verifies the iterator returns elements in FIFO order
     * for a full queue.
     */
    @Test
    public void iteratorFullTest()
    {
        addElementsToFullQueue();
        verifyIteratorElements(testArray.length);
    }

    /**
     * Verifies the iterator returns elements in FIFO order
     * for a partially full queue.
     */
    @Test
    public void iteratorPartialTest()
    {
        addElementsToPartialQueue();
        verifyIteratorElements(testArray.length / 2);
    }

    private void verifyIteratorElements(int maxIndex)
    {
        //verify elements returned in FILO order
        Iterator<Integer> iter = queue.iterator();
        for (int i = 0; i < maxIndex; i++)
        {
            Assert.assertTrue("hasNext() should return true for existing elements in the queue",
                    iter.hasNext());
            Assert.assertEquals("next() should return elements in FIFO order",
                    testArray[i], iter.next().intValue());
        }

        Assert.assertFalse("Iterator should not report more elements after all have been returned",
                iter.hasNext());
    }

    /**
     * Verifies that the for-each loop works with the iterator
     */
    @Test
    public void forEachTest()
    {
        addElementsToFullQueue();

        //a for-each loop should run without error
        int count = 0;
        for (int element : queue)
        {
            Assert.assertEquals("next() should return elements in FIFO order",
                    testArray[count], element);
            count++;
        }
    }

    /**
     * Verifies that elements cannot be removed from the
     * queue while using the iterator.
     */
    @Test(expected = ConcurrentModificationException.class)
    public void concurrentRemoveTest()
    {
        addElementsToFullQueue();

        for (int element : queue)
        {
            assert element != 0;
            queue.remove(); //alter elements while iterating
        }
    }

    /**
     * Verifies that elements cannot be added to the
     * queue while using the iterator.
     */
    @Test(expected = ConcurrentModificationException.class)
    public void concurrentAddTest()
    {
        addElementsToPartialQueue();

        for (int element : queue)
        {
            queue.add(element); //alter elements while iterating
        }
    }

    /**
     * Verifies that elements cannot be removed (using clear())
     * from the queue while using the iterator.
     */
    @Test(expected = ConcurrentModificationException.class)
    public void concurrentClearTest()
    {
        addElementsToFullQueue();

        for (int element : queue)
        {
            assert element != 0;
            queue.clear(); //alter elements while iterating
        }
    }

    private void addElementsToFullQueue()
    {
        for (int i = 0; i < testArray.length; i++)
        {
            queue.add(testArray[i]);
        }
        Assert.assertEquals("The size of your queue should be " + testArray.length +
                            " after calling add() " + testArray.length + " times",
                            testArray.length, queue.size());
    }

    private void addElementsToPartialQueue()
    {
        int length = (testArray.length / 2);
        for (int i = 0; i < testArray.length / 2; i++)
        {
            queue.add(testArray[i]);
        }
        Assert.assertEquals("The size of your queue should be " + length +
                            " after calling add() " + length + " times",
                            length, queue.size());
    }
}


