package tests;

import adts.IReversibleStack;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Tests an implementation of the IReversibleStack interface.
 *
 * DO NOT EDIT THIS FILE!
 *
 * @author Josh Archer
 * @version 1.0
 */
public class StackTest
{
    private IReversibleStack<Integer> stack;

    //test elements
    private int[] testElemsOdd = new int[] {1, 2, 3, 4, 5, 6, 7};
    private int[] testElemsEven = new int[] {1, 2, 3, 4, 5, 6, 7, 8};

    /*
        This method should create and return a new stack
        for the methods below.
     */
    private IReversibleStack<Integer> createStack()
    {
        return null;
    }

    /**
     * Creates a new reversible stack for each test below.
     */
    @Before
    public void setup()
    {
        stack = createStack();
    }

    /**
     * Tests whether the adding new elements to the stack
     * is working correctly
     */
    @Test
    public void addingElementsTest()
    {
        int[] elemsToAdd = {1, 2, 3};
        for (int i = 0; i < elemsToAdd.length; i++)
        {
            stack.add(elemsToAdd[i]);
        }

        for (int i = 0; i < elemsToAdd.length; i++)
        {
            Assert.assertTrue("Elements added to stack not discoverable with contains()",
                    stack.contains(elemsToAdd[i]));
        }
    }

    /**
     * Tests whether the size of the stack is calculated
     * correctly.
     */
    @Test
    public void sizeTest()
    {
        //add a few elements
        int[] elemsToAdd = {2, 4, 6};
        for (int i = 0; i < elemsToAdd.length; i++)
        {
            stack.add(elemsToAdd[i]);
        }

        //stack should be empty to start with
        Assert.assertEquals("Stack should have size 3 after three calls to add()", 3, stack.size());
        Assert.assertFalse("Stack should not be empty after calling add()", stack.isEmpty());
    }

    /**
     * Tests whether elements in the stack can be found
     * with contains().
     */
    @Test
    public void containsExistsTest()
    {
        //add a few elements
        int[] elemsToAdd = {2, 4, 6};
        for (int i = 0; i < elemsToAdd.length; i++)
        {
            stack.add(elemsToAdd[i]);
        }
        Assert.assertEquals("The size of your stack should be 3 after calling add() 3 times",
                3, stack.size());

        //make sure elements are discoverable
        for (int i = 0; i < elemsToAdd.length; i++)
        {
            Assert.assertTrue("Added element not discoverable by contains()",
                    stack.contains(elemsToAdd[i]));
        }
    }

    /**
     * Tests whether elements that are not in the stack
     * can be found.
     */
    @Test
    public void containsMissingTest()
    {
        //add a few elements
        int[] elemsToAdd = {2, 4, 6};
        for (int i = 0; i < elemsToAdd.length; i++)
        {
            stack.add(elemsToAdd[i]);
        }
        Assert.assertEquals("The size of your stack should be 3 after calling add() 3 times",
                3, stack.size());

        //make sure elements are discoverable
        int[] notAdded = {1, 3, 5};
        for (int i = 0; i < notAdded.length; i++)
        {
            Assert.assertFalse("Missing element is discoverable by contains()",
                    stack.contains(notAdded[i]));
        }
    }

    /**
     * Tests how the contains() method behaves with an empty stack.
     */
    @Test
    public void containsOnEmptyStackTest()
    {
        //contains should always return false on empty stack
        Assert.assertFalse("Missing element is discoverable by contains()",
                stack.contains(2));

        //add an element and confirm contains() can discover it
        stack.add(2);
        Assert.assertTrue("Element added to stack is not discoverable by contains()",
                stack.contains(2));
    }

    /**
     * Tests whether remove() can be called successfully
     * on the stack.
     */
    @Test
    public void removeTest()
    {
        //add a few elements
        int[] elemsToAdd = {2, 4, 6};
        for (int i = 0; i < elemsToAdd.length; i++)
        {
            stack.add(elemsToAdd[i]);
        }

        for (int i = 1; i <= 3; i++)
        {
            stack.remove();
        }

        Assert.assertEquals("Stack size should be 0 after removing all elements", 0, stack.size());
        Assert.assertTrue("Stack should be empty after removing all elements", stack.isEmpty());
    }

    /**
     * Verifies that calling remove() with an empty stack
     * throws an exception.
     */
    @Test(expected = NoSuchElementException.class)
    public void removeOnEmptyStackTest()
    {
        //no elements are present, this should give an exception
        stack.remove();
    }

    /**
     * Verifies that calling remove(element) throws an exception.
     */
    @Test(expected = UnsupportedOperationException.class)
    public void removeNotImplementedTest()
    {
        //this method should not be implemented
        stack.remove(2);
    }

    /**
     * Verifies that elements are stored in FILO order in the stack.
     */
    @Test
    public void filoTest()
    {
        //add a few elements
        int[] elemsToAdd = {2, 4, 6};
        for (int i = 0; i < elemsToAdd.length; i++)
        {
            stack.add(elemsToAdd[i]);
        }

        //remove them in order
        for (int i = 1; i <= 3; i++)
        {
            int removed = stack.remove();
            Assert.assertEquals("Elements removed are not in FILO order",
                    elemsToAdd[elemsToAdd.length - i], removed);
        }
    }

    /**
     * Makes several calls to add() and remove() and verifies
     * that the order of calls does not result in an error.
     */
    @Test
    public void stackFluctuationsTest()
    {
        //add a few
        stack.add(1);
        stack.add(2);
        stack.add(3);

        //remove some, not all
        Assert.assertEquals("Elements removed are not in FILO order",
                3, stack.remove().intValue());
        Assert.assertEquals("Elements removed are not in FILO order",
                2, stack.remove().intValue());

        //add a few more
        stack.add(4);
        stack.add(5);

        //remove the remaining and verify
        Assert.assertEquals("Elements removed are not in FILO order",
                5, stack.remove().intValue());
        Assert.assertEquals("Elements removed are not in FILO order",
                4, stack.remove().intValue());
        Assert.assertEquals("Elements removed are not in FILO order",
                1, stack.remove().intValue());

        Assert.assertEquals("Stack size should be 0 after removing all elements", 0, stack.size());
        Assert.assertTrue("Stack should be empty after removing all elements", stack.isEmpty());
    }

    /**
     * Verifies that the clear() method runs as expected on an empty stack.
     */
    @Test
    public void clearEmptyTest()
    {
        //make sure no errors are encountered
        stack.clear();

        Assert.assertEquals("Stack size should be 0 after calling clear()", 0, stack.size());
        Assert.assertTrue("Stack should be empty after calling clear", stack.isEmpty());
    }

    /**
     * Verifies that the clear() method runs as expected on a stack
     * with elements.
     */
    @Test
    public void clearNotEmptyTest()
    {
        //add a few elements
        int[] elemsToAdd = {2, 4, 6};
        for (int i = 0; i < elemsToAdd.length; i++)
        {
            stack.add(elemsToAdd[i]);
        }
        Assert.assertEquals("The size of your stack should be 3 after calling add() 3 times",
                3, stack.size());

        //make sure no errors are encountered
        stack.clear();

        Assert.assertEquals("Stack size should be 0 after calling clear()", 0, stack.size());
        Assert.assertTrue("Stack should be empty after calling clear", stack.isEmpty());
    }

    /**
     * Assembles a large stack of elements and verifies
     * that the stack is growing and shrinking as expected.
     */
    @Test
    public void largeStackTest()
    {
        //add enough elements for force a resize
        for (int i = 1; i <= 1000; i++)
        {
            stack.add(i);
        }

        //verify elements are in order
        for (int i = 0; i < 1000; i++)
        {
            int removed = stack.remove();
            Assert.assertEquals("Elements are not returned in FILO order",
                    1000 - i, removed);
        }
    }

    /**
     * Empties the stack and then verifies that add() works correctly.
     */
    @Test
    public void addAfterEmptyingStackTest()
    {
        //add a few elements
        int[] elemsToAdd = {2, 4, 6};
        for (int i = 0; i < elemsToAdd.length; i++)
        {
            stack.add(elemsToAdd[i]);
        }
        Assert.assertEquals("The size of your stack should be 3 after calling add() 3 times",
                3, stack.size());

        //remove all elements
        for (int i = 0; i < elemsToAdd.length; i++)
        {
            stack.remove();
        }

        //adding should still be successful
        stack.add(2);
        Assert.assertEquals("The size of your stack should be 1 after calling add() on an empty stack",
                1, stack.size());
    }

    /**
     * Tests whether calling reverse() on an empty stack works correctly.
     */
    @Test
    public void reverseEmptyStackTest()
    {
        //reversing an empty stack should still be empty
        stack.reverse();

        Assert.assertEquals("Stack size should be 0 after calling clear()", 0, stack.size());
        Assert.assertTrue("Stack should be empty after calling clear", stack.isEmpty());
    }

    /**
     * Adds an odd number of elements to the stack and
     * then verifies the results after calling reverse().
     */
    @Test
    public void reverseOddLengthTest()
    {
        testLengths(testElemsOdd);
    }

    /**
     * Adds an even number of elements to the stack and
     * then verifies the results after calling reverse().
     */
    @Test
    public void reverseEvenLengthTest()
    {
        testLengths(testElemsEven);
    }

    private void testLengths(int[] elemsToAdd)
    {
        //add a few elements
        for (int i = 0; i < elemsToAdd.length; i++)
        {
            stack.add(elemsToAdd[i]);
        }
        Assert.assertEquals("The size of your stack should be " + elemsToAdd.length +
                            " after calling add() " + elemsToAdd.length + " times",
                            elemsToAdd.length, stack.size());

        stack.reverse();

        //make sure elements are returned in reverse order
        for (int i = 0; i < elemsToAdd.length; i++)
        {
            int removed = stack.remove();
            Assert.assertEquals("Elements in stack are not returned in reverse order",
                    elemsToAdd[i], removed);
        }

        Assert.assertEquals("Stack size should be 0 after removing all elements", 0, stack.size());
        Assert.assertTrue("Stack should be empty after removing all elements", stack.isEmpty());
    }

    /**
     * Tests the reverse() method on a large number of elements.
     */
    @Test
    public void reverseLargeStackTest()
    {
        //add a few elements
        for (int i = 1; i <= 1000; i++)
        {
            stack.add(i);
        }
        Assert.assertEquals("The size of your stack should be 1000 after calling add() 1000 times",
                1000, stack.size());

        stack.reverse();

        //make sure elements are returned in reverse order
        for (int i = 1; i <= 1000; i++)
        {
            Assert.assertEquals("Elements in stack are not returned in reverse order",
                    i, stack.remove().intValue());
        }
    }

    /**
     * Calls reverse() twice on the stack and verifies
     * that elements are in the original order
     */
    @Test
    public void doubleReverseTest()
    {
        //add a few elements
        for (int i = 0; i < testElemsEven.length; i++)
        {
            stack.add(testElemsEven[i]);
        }
        Assert.assertEquals("The size of your stack should be 6 after calling add() 6 times",
                testElemsEven.length, stack.size());

        stack.reverse(); //reverse order
        stack.reverse(); //original order

        //make sure elements are returned in reverse order
        for (int i = 0; i < testElemsEven.length; i++)
        {
            Assert.assertEquals("Elements in stack are not returned in reverse order",
                    testElemsEven[testElemsEven.length - i - 1], stack.remove().intValue());
        }
    }

    /**
     * Verifies that an iterator can be retrieves with an
     * empty stack.
     */
    @Test
    public void iteratorWithEmptyStackTest()
    {
        Iterator<Integer> iter = stack.iterator();
        Assert.assertFalse("Iterator should not report elements for an empty stack",
                            iter.hasNext());
    }

    /**
     * Tests whether elements are returned as expected with the
     * iterator.
     */
    @Test
    public void iteratorTest()
    {
        //add a few elements
        for (int i = 0; i < testElemsEven.length; i++)
        {
            stack.add(testElemsEven[i]);
        }
        Assert.assertEquals("The size of your stack should be " + testElemsEven.length +
                " after calling add() " + testElemsEven.length + " times",
                testElemsEven.length, stack.size());

        //verify elements returned in FILO order
        Iterator<Integer> iter = stack.iterator();
        for (int i = testElemsEven.length - 1; i >= 0; i--)
        {
            Assert.assertTrue("hasNext() should return true for existing elements in the stack",
                    iter.hasNext());
            Assert.assertEquals("next() should return elements in FILO order",
                    testElemsEven[i], iter.next().intValue());
        }

        Assert.assertFalse("Iterator should not report more elements after all have been returned",
                iter.hasNext());
    }

    /**
     * Verifies that the for-each loop works as expected
     * with the provided iterator
     */
    @Test
    public void forEachTest()
    {
        //add a few elements
        for (int i = 0; i < testElemsOdd.length; i++)
        {
            stack.add(testElemsOdd[i]);
        }
        Assert.assertEquals("The size of your stack should be " + testElemsOdd.length +
                " after calling add() " + testElemsOdd.length + " times",
                testElemsOdd.length, stack.size());

        //a for-each loop should run without error
        int count = 0;
        for (int element : stack)
        {
            Assert.assertEquals("next() should return elements in FILO order",
                    testElemsOdd[testElemsOdd.length - 1 - count], element);
            count++;
        }
    }

    /**
     * Verifies that concurrent changes cannot be made with the
     * remove() method.
     */
    @Test(expected = ConcurrentModificationException.class)
    public void concurrentRemoveTest()
    {
        //add a few elements
        int[] elemsToAdd = {2, 4, 6};
        for (int i = 0; i < elemsToAdd.length; i++)
        {
            stack.add(elemsToAdd[i]);
        }

        for (int element : stack)
        {
            assert element != 0;
            stack.remove(); //alter elements while iterating
        }
    }

    /**
     * Verifies that concurrent changes cannot be made with the
     * clear() method.
     */
    @Test(expected = ConcurrentModificationException.class)
    public void concurrentClearTest()
    {
        //add a few elements
        int[] elemsToAdd = {2, 4, 6};
        for (int i = 0; i < elemsToAdd.length; i++)
        {
            stack.add(elemsToAdd[i]);
        }

        for (int element : stack)
        {
            assert element != 0;
            stack.clear(); //alter elements while iterating
        }
    }

    /**
     * Verifies that concurrent changes cannot be made with the
     * add() method.
     */
    @Test(expected = ConcurrentModificationException.class)
    public void concurrentAddTest()
    {
        //add a few elements
        int[] elemsToAdd = {2, 4, 6};
        for (int i = 0; i < elemsToAdd.length; i++)
        {
            stack.add(elemsToAdd[i]);
        }

        for (int element : stack)
        {
            stack.add(element); //alter elements while iterating
        }
    }
}
